
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<title>Orbit</title>
    <link rel="stylesheet" href="http://www.keplerproject.org/doc.css" type="text/css"/>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
</head>

<body>

<div id="container">

<div id="product">

	<div id="product_logo">
        <a href="http://www.keplerproject.org">
		<img alt="Orbit" src="orbit.png"/>
	    </a>
    </div>
	<div id="product_name"><big><strong>Orbit</strong></big></div>
	<div id="product_description">MVC for Lua Web Development</div>
</div> <!-- id="product" -->

<div id="main">
	
<div id="navigation">
<h1>Orbit</h1>
	<ul>

		<li><a href="index.html">Home</a>
			<ul> 
                            
			</ul>
		</li>

		<li><a href="pages.html">Pages</a>
			<ul> 
                            
			</ul>
		</li>

		<li><strong>Reference</strong>
			<ul> 
                            
			</ul>
		</li>

		<li><a href="example.html">Tutorial</a>
			<ul> 
                            
			</ul>
		</li>

		<li><a href="license.html">License</a>
			<ul> 
                            
			</ul>
		</li>

	</ul>
</div> <!-- id="navigation" -->

<div id="content">


<h2>Reference Manual</h2>

<p>This is a short reference of all of Orbit's (and Orbit apps) methods.</p>

<h2>Module <code>orbit</code></h2>

<p><strong>orbit.new([<em>app</em>])</strong> - creates a new Orbit application, returning it (as a module).
If <em>app</em> is a string this is the application's name, and sets field _NAME. If <em>app</em>
is a table it is used instead of a fresh table. This means you can pass <code>orbit.new</code>
to the <code>module</code> function</p>

<p><strong>orbit.htmlify(<em>func</em>[, <em>func</em>...])</strong> - modifies the environment of <em>func</em> to
include functions that generate HTML</p>

<h2>Orbit apps</h2>

<p><strong>app.run(<em>wsapi_env</em>)</strong> - WSAPI entry point for application, generated by Orbit</p>

<p><strong>app.real_path</strong> - the root of the application in the filesystem, defaults to
the path inferred by WSAPI launchers (<code>wsapi.app\_path</code>), but can be overridden</p>

<p><strong>app.mapper</strong> - mapper used by <code>app:model</code>, defaults to an instance of <code>orbit.model</code>,
but can be overridden</p>

<p><strong>app.not_found</strong> - default handler, sends a 404 response to the client, can be overridden.
The handler receives a <code>web</code> object</p>

<p><strong>app.server_error</strong> - error handler, sends a 500 response with stack trace to the
client, can be overridden. The handler receives a <code>web</code> object</p>

<p><strong>app:dispatch_get(<em>func</em>, <em>patt</em>[, <em>patt</em>...])</strong> - installs <em>func</em> as a GET handler for
the patterns <em>patt</em>. <em>func</em> receives a <code>web</code> object and the captures; this handler should return
the contents of the response or <strong>app.reparse</strong> if you want to hand control back to
the dispatcher and let it continue matching;</p>

<p><strong>app:dispatch_post(<em>func</em>, <em>patt</em>[, <em>patt</em>...])</strong> - installs <em>func</em> as a POST handler for
the patterns <em>patt</em>. <em>func</em> receives a <code>web</code> object and the captures; this handler should return
the contents of the response or <strong>app.reparse</strong> if you want to hand control back to
the dispatcher and let it continue matching;</p>

<p><strong>app:dispatch_put(<em>func</em>, <em>patt</em>[, <em>patt</em>...])</strong> - installs <em>func</em> as a PUT handler for
the patterns <em>patt</em>. <em>func</em> receives a <code>web</code> object and the captures; this handler should return
the contents of the response or <strong>app.reparse</strong> if you want to hand control back to
the dispatcher and let it continue matching;</p>

<p><strong>app:dispatch_delete(<em>func</em>, <em>patt</em>[, <em>patt</em>...])</strong> - installs <em>func</em> as a DELETE handler for
the patterns <em>patt</em>. <em>func</em> receives a <code>web</code> object and the captures; this handler should return
the contents of the response or <strong>app.reparse</strong> if you want to hand control back to
the dispatcher and let it continue matching;</p>

<p><strong>app:dispatch_wsapi(<em>func</em>, <em>patt</em>[, <em>patt</em>...])</strong> - installs <em>func</em> as a WSAPI handler for
the patterns <em>patt</em>. <em>func</em> receives the unmodified WSAPI environment</p>

<p><strong>app:dispatch_static(<em>patt</em>[, <em>patt</em>...])</strong> - installs a static files handler for
the patterns <em>patt</em>. This handler assumes the PATH_INFO is a file relative to
<code>app.real_path</code> and sends it to the client. The MIME type is detected from
the extension (default application/octec-stream)</p>

<p><strong>app:serve_static(<em>web</em>, <em>filename</em>)</strong> - returns the content of file <em>filename</em> (which can be
anywhere in the filesystem), while setting the appropriate headers with the file's MIME
type</p>

<p><strong>app:htmlify(<em>patt</em>[, <em>patt</em>...])</strong> - same as <code>orbit.htmlify</code>, but changes all of the
app's module functions that match the patterns <em>patt</em></p>

<p><strong>app:model(...)</strong> - calls <code>app.mapper:new(...)</code>, so the behaviour depends on the mapper
you are using</p>

<h2><code>web</code> methods</h2>

<p>The <em>web</em> objects inherit the functions of module <code>wsapi.util</code> as methods.</p>

<p><strong>web.status</strong> - status to be sent to server (default: "200 Ok")</p>

<p><strong>web.headers</strong> - headers to be sent to server, a Lua table (default has Content-Type as text/html)</p>

<p><strong>web.response</strong> - body to send to the server (default is blank)</p>

<p><strong>web.vars</strong> - original WSAPI environment</p>

<p><strong>web.prefix</strong> - app's prefix (if set in the app's module) or SCRIPT_NAME</p>

<p><strong>web.suffix</strong> - app's suffix (if set in the app's module)</p>

<p><strong>web.real_path</strong> - location of app in filesystem, taken from wsapi_env.APP_PATH, or app's module real_path, or "."</p>

<p><strong>web.doc_root, web.path_info, web.script_name, web.path_translated, web.method</strong> - server's document root, PATH_INFO,
SCRIPT_NAME, PATH_TRANSLATED, and REQUEST_METHOD (converted to lowercase)</p>

<p><strong>web.GET, web.POST</strong> - GET and POST variables</p>

<p><strong>web.input</strong> - union of web.GET and web.POST</p>

<p><strong>web.cookies</strong> - cookies sent by the browser</p>

<p><strong>web:set_cookie(<em>name</em>, <em>value</em>)</strong> - sets a cookie to be sent back to browser</p>

<p><strong>web:delete_cookie(<em>name</em>)</strong> - deletes a cookie</p>

<p><strong>web:redirect(<em>url</em>)</strong> - sets status and headers to redirect to <em>url</em></p>

<p><strong>web:link(<em>part</em>, [<em>params</em>])</strong> - creates intra-app link, using web.prefix and web.suffix, and encoding <em>params</em>
as a query string</p>

<p><strong>web:static_link(<em>part</em>)</strong> - if app's entry point is a script, instead of path, creates a link to the app's vpath
(e.g. if app.prefix is /foo/app.ws creates a link in /foo/<em>part</em>), otherwise same as web:link</p>

<p><strong>web:empty(<em>s</em>)</strong> - returns true if <em>s</em> is nil or an empty string (zero or more spaces)</p>

<p><strong>web:content_type(<em>s</em>)</strong> - sets the content type of the reponse to <em>s</em></p>

<p><strong>web:empty_param(<em>name</em>)</strong> - returns true if input parameter <em>name</em> is empty (as web:empty)</p>

<p><strong>web:page(<em>name</em>, [<em>env</em>])</strong> - loads and renders Orbit page called <em>name</em>. If <em>name</em> starts with / it's relative to
the document root, otherwise it's relative to the app's path. Returns rendered page. <em>env</em> is an optional environment
with extra variables.</p>

<p><strong>web:page_inline(<em>contents</em>, [<em>env</em>])</strong> - renders an inline Orbit page</p>

<h2>Module <code>orbit.cache</code></h2>

<p><strong>orbit.cache.new(<em>app</em>, [<em>base_path</em>])</strong> - creates a page cache for <em>app</em>, either in memory or at the filesystem
path <em>base_path</em> (<strong>not</strong> relative to the app's path!), returns the cache object</p>

<p><strong>a_cache(<em>handler</em>)</strong> - caches <em>handler</em>, returning a new handler; uses the PATH_INFO as a key to the cache</p>

<p><strong>a_cache:get(<em>key</em>)</strong> - gets value stored in <em>key</em>; usually not used, use the previous function instead</p>

<p><strong>a_cache:set(<em>key</em>, <em>val</em>)</strong> - stores a value in the cache; use a_cache(<em>handler</em>) to encapsulate this behaviour</p>

<p><strong>a_cache:invalidate(<em>key</em>)</strong> - invalidates a cache value</p>

<p><strong>a_cache:nuke()</strong> - clears the cache</p>

<h2>Module <code>orbit.model</code></h2>

<p><strong>orbit.model.new([<em>table_prefix</em>], [<em>conn</em>], [<em>driver</em>], [<em>logging</em>])</strong> - creates a new ORM mapper. <em>table_prefix</em> (default "")
is a string added to the start of model names to get table names; <em>conn</em> is the database connection (can be set
later); <em>driver</em> is the kind of database (currently "sqlite3", the default, and "mysql");  <em>logging</em> 
sets whether you want logging of all queries to <code>io.stderr</code>. Returns a mapper instance,
and all the parameters can be set after this instance is created (via a_mapper.table_prefix, a_mapper.conn, 
a_mapper.driver, and a_mapper.logging)</p>

<p><strong>orbit.model.recycle(<em>conn_builder</em>, <em>timeout</em>)</strong> - creates a connection using <em>conn_builder</em>, a function
that takes no arguments, and wraps it so a new connection is automatically reopened every <em>timeout</em> seconds</p>

<p><strong>a_mapper:new(<em>name</em>, [<em>tab</em>])</strong> - creates a new model object; <em>name</em> is used together with a_mapper.table_prefix to
form the DB table's name; fields and types are introspected from the table. <em>tab</em> is an optional table that
is used as the basis for the model object if present</p>

<p><strong>a_model.model</strong> - the mapper for this model</p>

<p><strong>a_model.name, a_model.table_name</strong> - the name of the model and its backing table</p>

<p><strong>a_model.driver</strong> - the DB driver used</p>

<p><strong>a_model.meta</strong> - metainformation about the model, introspected from the table</p>

<p><strong>a_model:find(<em>id</em>)</strong> - finds and returns the instance of the model with the passed <em>id</em> (keyed using
the <code>id</code> column of the table (must be numeric)</p>

<p><strong>a_model:find_first(<em>condition</em>, <em>args</em>)</strong> - finds and returns the first instance of the model that
matches <em>condition</em>; <em>args</em> can determine the order (args.order), specify which fields should be returned
(args.fields, default is all of them), and inject fields from other tables
(args.inject)</p>

<p>Example: <code>books:find_first("author = ? and year_pub &gt; ?", { "John Doe", 1995, order = "year_pub asc" })</code></p>

<p><strong>a_model:find_all(<em>condition</em>, <em>args</em>)</strong> - finds and returns all instances of the model that
matches <em>condition</em>; <em>args</em> can determine the order (args.order), specify which fields should be returned
(args.fields, default is all of them), limit the number of returned rows (args.count), return only
distinct rows (args.distinct), and inject fields from other tables (args.inject)</p>

<p>Example: <code>books:find_all("author = ? and year_pub &gt; ?", { "John Doe", 1995, order = "year_pub asc", count = 5, fields = { "id", "title" } })</code></p>

<p><strong>a_model:new([<em>tab</em>])</strong> - creates a fresh instance of the model, optionally using <em>tab</em> as initial
values</p>

<p><strong>a_model:find_by_xxx(<em>args</em>)</strong> - finds and returns the first instance of the model building the
condition from the method name, a la Rails' ActiveRecord; <em>args</em> works the same way as in <strong>find_first</strong>, above</p>

<p><strong>a_model:find_all_by_xxx(<em>args</em>)</strong> - finds and returns all instances of the model building the
condition from the method name, a la Rails' ActiveRecord; <em>args</em> works the same way as in <strong>find_all</strong>, above</p>

<p>Example: <code>books:find_all_by_author_or_author{ "John Doe", "Jane Doe", order = "year_pub asc" }</code></p>

<p><strong>an_instance:save([<em>force_insert</em>])</strong> - saves an instance to the DB, commiting changes or creating the backing record if the instance is new; if <em>force_insert</em> is true always do an insert instead of an update</p>

<p>If there's a row called <code>created_at</code> this row is set to the creation date of the record; if there's a row
called <code>updated_at</code> this row is set to the last update's date.</p>

<p><strong>an_instance:delete()</strong> - deletes an instance from the DB</p>

<h2>Module <code>orbit.routes</code></h2>

<p>This module has a single function, <strong>R</strong>, and you can also call the module itself. This function takes a PATH_INFO pattern where the path segments (the parts of the path separated by <code>/</code> or <code>.</code>) can be named parameters (<code>:name</code>), <em>splats</em> (*), optional parameters (<code>?:name?</code>), or literals, and returns a pattern.</p>

<p>A pattern is an object with two methods:</p>

<p><strong>patt:match(<em>str</em>)</strong> - tries to match <em>str</em> and returns a hash of named parameters; splats are returned in a <code>splat</code> array inside this hash.</p>

<p><strong>patt:build(<em>params</em>)</strong> - builds the original pattern string from a hash of named parameters</p>

<p>Some examples of patterns, what they match, and the parameter hashes:</p>

<ul>
    <li>'/foo', matches '/foo', empty hash</li>
    <li>'/foo/:bar/baz' matches '/foo/orbit/baz' or '/foo/xxx.yyy/baz' with hashes { bar = 'orbit' } and { bar = 'xxx.yyy' }</li>
    <li>'/:name.:ext' matches '/xxx.yyy' or '/filename.ext' with hashes { name = 'xxx', ext = 'yyy' } and { name = 'filename', ext = 'ext' }</li>
    <li>'/<em>/foo/</em>' matches '/bar/foo' or '/bar/foo/bling/baz/boom' with hashes { splat = { 'bar' } } and { splat = { 'bar', 'bling/baz/boom' } }</li>
    <li>'/?:foo?/?:bar?' matches '/' or '/orbit' or '/orbit/routes' with hashes {} and { foo = 'orbit' } and { foo = 'orbit', bar = 'routes' }</li>
</ul>

<p>And several more, see <code>test/test_routes.lua</code> for a comprehensive test suite.</p>



</div> <!-- id="content" -->

</div> <!-- id="main" -->

<div id="about">
	<p><a href="http://validator.w3.org/check?uri=referer">Valid XHTML 1.0!</a></p>
</div> <!-- id="about" -->

</div> <!-- id="container" -->

</body>
</html>

